## 目录

[TOC]

------

## 1.Go语言特点

- 没有"对象"，没有继承与多态，没有泛型，没有try/catch

- 有接口，函数式编程，CSP并发模型（goroutine+channel）

- 语法简单

  #### 课程预览流程图

  ![1536746336818](E:\hugo-github\go_img\1536746336818.png)

  ![1536746361290](E:\hugo-github\go_img\1536746361290.png)

## 2.基本语法

### 内建变量类型

#### 备注

> 前面部分内容在幕布里面

#### 强制转化

##### int类型必须要定义，不能隐式转化，而且float是不准的

![1536559546546](./go_img/1536559546546.png)

### 常量与枚举

#### 常量可以定义也可以不定义

#### 当然类型的定义也是可以批量的加'()'即可

![1536560007066](./go_img/1536560007066.png)

![1536560166285](./go_img/1536560166285.png)

#### cpp=iota（iota代表的是之后的常量都是自增‘1,2,3...’）

#### 普通枚举类型

#### 自增值枚举类型

![1536560434794](./go_img/1536560434794.png)

#### 变量要点定义回顾

![1536560526218](./go_img/1536560526218.png)

### 条件语句

#### if

![1536560703018](./go_img/1536560703018.png)

![1536560897601](./go_img/1536560897601.png)

#### if的简写形式

![1536562412995](./go_img/1536562412995.png)

#### switch

![1536562621234](./go_img/1536562621234.png)

#### 实战switch

![1536562735796](./go_img/1536562735796.png)![1536562795835](./go_img/1536562795835.png)

##### switch后面可以没有表达式

### 循环

#### for

![1536574782110](./go_img/1536574782110.png)

#### for实战（将整数转化为二进制）

![1536575055032](./go_img/1536575055032.png)

![1536574994322](./go_img/1536574994322.png)

![1536575212065](./go_img/1536575212065.png)

##### go语言的死循环

![1536575166058](./go_img/1536575166058.png)

##### 初始，递增都可以省略（什么都省略就是死循环了）

![1536575253306](./go_img/1536575253306.png)

#### 基本语法要点回顾

![1536575340626](./go_img/1536575340626.png)

### 函数

![1536575422973](./go_img/1536575422973.png)

![1536575582001](./go_img/1536575582001.png)

###### 这里是作为参数

#### 函数式编程的特点

![1536575496960](./go_img/1536575496960.png)



#### 可变参数列表

![1536575678162](./go_img/1536575678162.png)

#### 要点回顾

![1536575736395](./go_img/1536575736395.png)

### 指针

#### go语言的指针是不能运算的

![1536575824050](./go_img/1536575824050.png)

#### c++代码说明值传递，引用传递的区别

![1536575870779](./go_img/1536575870779.png)

##### 正确答案最好是：3			4

##### Go语言只有值传递一种方式

#### 参数传递

![1536635410700](E:\hugo-github\go_img\1536635410700.png)

##### 第二种传递方式

![536635505138](E:\hugo-github\go_img\1536635505138.png)

##### 第三种传递方式

![1536636584338](C:\Users\ADMINI~1\AppData\Local\Temp\1536636584338.png)

![1536636683112](E:\hugo-github\go_img\1536636683112.png)

![1536636730487](E:\hugo-github\go_img\1536636730487.png)

## 3.内建容器

### 数组，切片与容器

### 数组

#### 数组写法的区别

![1536648451631](E:\hugo-github\go_img\1536648451631.png)![1536650111007](E:\hugo-github\go_img\1536650111007.png)

![1536650154927](E:\hugo-github\go_img\1536650154927.png)

#### range遍历的一些用法

![1536650269943](E:\hugo-github\go_img\1536650269943.png)

#### 遍历注意点

![1536650333624](E:\hugo-github\go_img\1536650333624.png)

#### 对range的说明

![1536650438809](E:\hugo-github\go_img\1536650438809.png)

#### 数组是值类型

 ![1536650675297](E:\hugo-github\go_img\1536650675297.png)

#### 切片

![1536650828961](E:\hugo-github\go_img\1536650828961.png)

##### reslice的用法

![1536650917310](E:\hugo-github\go_img\1536650917310.png)

##### slice的实现图

![1536651028129](E:\hugo-github\go_img\1536651028129.png)

##### slice的扩展

![1536651069081](E:\hugo-github\go_img\1536651069081.png)

##### 向slice添加元素

![1536651232864](E:\hugo-github\go_img\1536651232864.png)

#### Map

![1536651279216](E:\hugo-github\go_img\1536651279216.png)

##### Map的操作

![1536651338097](E:\hugo-github\go_img\1536651338097.png)

##### Map的遍历

![1536651385601](E:\hugo-github\go_img\1536651385601.png)

##### Map的key

![1536651456785](E:\hugo-github\go_img\1536651456785.png)

#### 章节实列

##### 寻找最长不含有重复字符的子串

###### [leetcode链接](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/)

![1536651546225](E:\hugo-github\go_img\1536651546225.png)

###### 解决方法

![1536651822608](E:\hugo-github\go_img\1536651822608.png)

###### 代码部分

![1536651922353](E:\hugo-github\go_img\1536651922353.png)

![1536651952177](E:\hugo-github\go_img\1536651952177.png)

##### rune相当于go的char

![1536652199662](E:\hugo-github\go_img\1536652199662.png)

##### 其他字串串操作

###### 通过strings.调出还有哪些字符串可以调用

![1536652328768](E:\hugo-github\go_img\1536652328768.png)

## 4.面向对象

### 面向对象

#### 这里只有封装，并没有继承与多态

##### ——更多的是面向接口的开发

![1536654891806](E:\hugo-github\go_img\1536654891806.png)

##### 残缺部分

![1536655118959](E:\hugo-github\go_img\1536655118959.png)

##### 实列

![1536655163655](E:\hugo-github\go_img\1536655163655.png)

#### 结构的创建

![1536655241231](E:\hugo-github\go_img\1536655241231.png)

##### 结构创建像其他的如java都是在堆上的

###### 而在go语言里面不需要知道

##### 通过遍历建立树

![1536655508903](E:\hugo-github\go_img\1536655508903.png)

##### 为结构定义方法

###### 其实就是其中的一种写法，语法糖

![1536655944383](E:\hugo-github\go_img\1536655944383.png)

![1536656018232](E:\hugo-github\go_img\1536656018232.png)

###### **值接收者**VS指针接收者

指针接收者

![1536659647478](E:\hugo-github\go_img\1536659647478.png)

值接收者

![1536659806728](E:\hugo-github\go_img\1536659806728.png)



#### 包和封装

##### 封装

![1536716839144](E:\hugo-github\go_img\1536716839144.png)

##### 包

![1536717054058](E:\hugo-github\go_img\1536717054058.png)

![1536717092731](E:\hugo-github\go_img\1536717092731.png)

##### 包的扩展

![1536717140922](E:\hugo-github\go_img\1536717140922.png)

##### GOPATH环境变量（环境变量的设置，哪怕是在hugo里面同样也需要设置）

![1536717218411](E:\hugo-github\go_img\1536717218411.png)

![1536717407217](E:\hugo-github\go_img\1536717407217.png)

![1536717424538](E:\hugo-github\go_img\1536717424538.png)

###### 一般情况都是以这样的形式产生

![1536717475703](E:\hugo-github\go_img\1536717475703.png)

##### go get获取第三方库

![1536717382266](E:\hugo-github\go_img\1536717382266.png)

## 5.面向接口

### 接口

这里的Traversal也就是遍历的作用

![1536717710163](E:\hugo-github\go_img\1536717710163.png)

#### duck typing

更多的是根据对象的功能性来进行研究的

![1536717984442](E:\hugo-github\go_img\1536717984442.png)

##### python里面的duck typing

![1536718229379](E:\hugo-github\go_img\1536718229379.png)

##### go语言重的接口

![1536718392353](E:\hugo-github\go_img\1536718392353.png)

##### 接口的定义

![1536718487075](E:\hugo-github\go_img\1536718487075.png)

##### 接口的实现

- 接口的实现是隐式的
- 只要实现接口里面的方法

##### 接口变量里面有什么

- 接口变量自带指针
- 接口变量同样采用值传递，几乎不需要使用接口的指针
- 指针接收者实现只能以指针方式使用，而值接收者都可以

![1536718605738](E:\hugo-github\go_img\1536718605738.png)

![1536718623802](E:\hugo-github\go_img\1536718623802.png)

##### 查看接口变量

![1536719146771](E:\hugo-github\go_img\1536719146771.png)

###### 注意接口的组合

![1536720059885](E:\hugo-github\go_img\1536720059885.png)

##### 常用系统接口

- 特殊接口：

  其实就是加一个对应的方法就行

  > stringer
  >
  > Reader/Writer

## 6.函数式编程

### 函数与闭包

![1536723308938](E:\hugo-github\go_img\1536723308938.png)

#### 函数式编程VS函数指针

![1536723382145](E:\hugo-github\go_img\1536723382145.png)

#### “正统”函数式编程

![1536723459967](E:\hugo-github\go_img\1536723459967.png)

#### 闭包

![1536723480090](E:\hugo-github\go_img\1536723480090.png)

##### python中的闭包

![1536723539050](E:\hugo-github\go_img\1536723539050.png)

##### go语言闭包的应用

![1536723607379](E:\hugo-github\go_img\1536723607379.png)

![1536723648010](E:\hugo-github\go_img\1536723648010.png)

## 7.错误处理与资源管理

### 错误处理

#### defer的调用

![1536732402717](E:\hugo-github\go_img\1536732402717.png)

![1536732444026](E:\hugo-github\go_img\1536732444026.png)

#### 错误处理

![1536732587692](E:\hugo-github\go_img\1536732587692.png)

##### 错误处理二

- 实现统一的错误处理逻辑

#### panic

![1536733586900](E:\hugo-github\go_img\1536733586900.png)

#### recover

![1536733640980](E:\hugo-github\go_img\1536733640980.png)

#### error VS panic

![1536733713189](E:\hugo-github\go_img\1536733713189.png)

### 错误处理综合实列

![1536733789201](E:\hugo-github\go_img\1536733789201.png)

## 8.测试与性能调优

### 测试

![1536734353976](E:\hugo-github\go_img\1536734353976.png)

#### 传统测试 VS 表格驱动测试

##### 传统测试

![1536734464531](E:\hugo-github\go_img\1536734464531.png)

![1536734499917](E:\hugo-github\go_img\1536734499917.png)

##### 表格驱动测试

![1536734523328](E:\hugo-github\go_img\1536734523328.png)

![1536734629893](E:\hugo-github\go_img\1536734629893.png)

##### 测试运行执行代码

##### 使用pprof进行性能调优

![1536734771195](E:\hugo-github\go_img\1536734771195.png)

###### 这样查看cpu.out文件

![1536734848833](E:\hugo-github\go_img\1536734848833.png)

然后help直接可以对应交互的命令行

直接web，生成svg的文件，框越大优化的空间就越大

![1536735409218](E:\hugo-github\go_img\1536735409218.png)

###### 上行上面的工具需要一个graphviz的，不然就生不出上面这张图

[Graphviz](http://www.graphviz.org/)

##### 测试

![1536734667527](E:\hugo-github\go_img\1536734667527.png)

###### 上面就用了表格驱动测试

###### 代码覆盖

![1536736075742](E:\hugo-github\go_img\1536736075742.png)

##### 性能测试

![1536736126528](E:\hugo-github\go_img\1536736126528.png)

##### http测试

![1536736183754](E:\hugo-github\go_img\1536736183754.png)

##### 写文档

## 9.Go语言的并发编程

### goroutine

![1536747157756](E:\hugo-github\go_img\1536747157756.png)

#### 协程coroutine

![1536747299576](E:\hugo-github\go_img\1536747299576.png)

##### 检测数据冲突

```shell
go run goroutine.go
```

```shell
go run -race goroutine.go
```

##### 子程序协程是一个特例

![1536747636305](E:\hugo-github\go_img\1536747636305.png)

##### 协程与普通函数的对比

![1536747771884](E:\hugo-github\go_img\1536747771884.png)

##### 其他语言的协程

###### C++与java中

![1536747850216](E:\hugo-github\go_img\1536747850216.png)

###### python中协程

![1536747892001](E:\hugo-github\go_img\1536747892001.png)

##### go语言重的goroutine线程解析图

![1536747986954](E:\hugo-github\go_img\1536747986954.png)

##### goroutine的定义

![1536748064178](E:\hugo-github\go_img\1536748064178.png)

###### 使用-race来检测数据访问冲突

##### goroutine可能切换的点

![1536748314587](E:\hugo-github\go_img\1536748314587.png)

用top可以查看CPU等的占有率

## 10.通道channel